
# Порівняння алгоритмів видачі решти: Жадібний алгоритм та Динамічне програмування

## Завдання
Розробити дві функції для системи касового апарату, яка видає решту:

1. Жадібний алгоритм (`find_coins_greedy`) — видає решту, завжди обираючи найбільший доступний номінал монети.
2. Алгоритм динамічного програмування (`find_min_coins`) — знаходить комбінацію монет, яка використовує мінімальну кількість монет для досягнення суми.

---

## Приклад (Сума: 113)

| Алгоритм | Результат                     | Час виконання (1000 запусків) |
|----------|-------------------------------|-------------------------------|
| Жадібний | {50: 2, 10: 1, 2: 1, 1: 1}     | ~0.0016 сек                   |
| ДП       | {50: 2, 10: 1, 2: 1, 1: 1}     | ~0.0814 сек                   |

---

## Висновки

- Жадібний алгоритм працює значно швидше і достатньо ефективно у випадку "гарних" номіналів монет, як у прикладі вище.
- Динамічне програмування гарантує мінімальну кількість монет навіть у випадках, коли жадібний підхід не працює оптимально, наприклад, для нестандартних наборів монет.
- У нашому випадку набір [50, 25, 10, 5, 2, 1] дозволяє жадібному алгоритму завжди повертати оптимальний результат. Але якби, наприклад, монета 4 існувала, greedy міг би повертати неефективну відповідь.

---

## Рекомендація

- Для високої швидкодії при типовому наборі монет — обирайте жадібний підхід.
- Для повної гарантії оптимальності у складніших наборах — використовуйте динамічне програмування.

## Бонус: чи є така сума що жадібний алгоритм знаходить неоптімальне рішення

- Теоретично: ні, для набору монет [50, 25, 10, 5, 2, 1] жадібний алгоритм завжди знаходить оптимальне рішення — тобто мінімальну кількість монет
- Цей набір монет називається канонічним набором монет — це означає, що для будь-якої суми жадібний підхід дає оптимальний результат.

    Це пов’язано з тим, що:

    Кожен менший номінал кратно доповнює більший:
    наприклад, 10 = 5+5, 25 = 10+10+5, і т.д.

    Немає “антиоптимальних комбінацій”, коли дві дрібні монети дають вигіднішу комбінацію, ніж одна велика

- Практично: перевіримо на практиці у розрахунку всіх сум до 500 (див. ht9-doya-01-bonus.py)
- Результат: Для всіх сум від 1 до 500 жадібний алгоритм дає оптимальний результат (як і динамічне програмування).# goit-algo-hw-09
